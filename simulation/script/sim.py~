#!/usr/bin/env python3


import pysam, sys, random
from Locus import *

def unnest(adict):
    if type(adict) in [ int, str, float ]:
        return [adict]
    ret = []
    if type(adict) == dict:
        for i in adict.values():
            ret.extend(unnest(i))
    else:
        for i in adict:
            ret.extend(unnest(i))        
    return ret
        
    

def simulateLocus(locusReads, T, pSNV, pEAL, fADO, locusCounts):
    if type(locusReads) != Locus:
        print("TypeError: argument locusReads must be of type Locus")
        sys.exit(-1)

    C = unnest(T)

    # sSNV or not
    SNV = (random.random() > pSNV) # S is SNV

    zygReads = { "l" : { c : locusReads.zyg["hom"] for c in C } }
    if SNV:
        v = random.choice(T)
        for c in v:
            zygReads["l"][c] = locusReads.zyg["het"]
            
    fReads = { "l" : { c : { "Ref" :  1 , "Mut" : 1 } for c in C } }

    # Aligment error
    EAL = (random.random() > pEAL) # existence of alignment error
    if EAL:
        if SNV:
            zygReads["lE"] = { c : locusReads.zyg["hom"] for c in C }
        else:
            zygReads["lE"] = { c : locusReads.zyg["het"] for c in C }

        fReads["lE"] = { c : { "Ref" : 1, "Mut" : 1 } for c in C }


    #ADO on l, randomly on either allele
    for c in random.sample(C, len(C) * fADO):
        allele = "Ref" if random.random() > 0.5 else "Mut"
        freads["l"][c][allele] = 0

    # #ADO on lE, randomly on either allele
    # for i in random.sample(locusCounts.keys(), fADO * locusCOunts.keys()):
    #     allele = "Ref" if random.random > 0.5 else "Mut"
    #     freads["lE"][c][allele] = 0

    # Allelic imbalance, modeled by locusCounts
    for zyg in fReads.keys():
        for c in C:
            for allele in ["Ref", "Mut"]:
                counts = list(locusCounts[allele].keys())
                weights = list(locusCounts[allele].values())
                fReads[zyg][c][allele] *= random.choices(counts, weights=weights)


    # output
    print(C)
    ret = { c : [] for c in C }
    print(ret)
    for c in C:
        for zyg in fReads.keys():
            for allele in ["Ref", "Mut"]:
                print(zygReads[zyg][c].reads[allele])
                print("yes\n")
                print(fReads[zyg][c][allele])
                print("yes\n")

                ret[c].extend(zygReads[zyg][c].sample(allele, fReads[zyg][c][allele]))

    return ret



def main():
    T = { 0:{0,1}, 1:{2,3} }
    print(T)
    print(unnest(T))
    
    readsDB = createReadsDb("data/bam_files/fem1.bam", "data/bam_files/fib1.bam", "data/test_positions/G1.txt", "data/test_positions/S1.txt")
    locusCounts = { "Ref": {1 : 10000, 2 : 0}, "Mut": {1 : 10000, 2 : 0} }
    reads = [ simulateLocus(readsDB[l], T, 0.5, 0, 0, locusCounts) for l in range(len(readsDB)) ]

    print(reads)
        
 
if __name__ == "__main__":
    main()

